{"version":3,"file":"tree-helisa.component.d.ts","sources":["tree-helisa.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { OnInit, EventEmitter, AfterViewInit, ElementRef } from '@angular/core';\nimport { NestedTreeControl } from '@angular/cdk/tree';\nimport { MatOptionSelectionChange } from '@angular/material/core';\nimport { MatTreeNestedDataSource, MatTree } from '@angular/material/tree';\nimport { Node } from './node';\nimport { TreeHelisaService } from './tree-helisa.service';\nimport { Router } from '@angular/router';\nimport { FormControl } from '@angular/forms';\nexport interface RequestTreeHelisa {\n    page: number;\n}\nexport declare class TreeHelisaComponent implements OnInit, AfterViewInit {\n    private treeHelisaService;\n    private router;\n    private elementRef;\n    isDisabled: boolean;\n    selectedNode: number | string | null;\n    constructor(treeHelisaService: TreeHelisaService, router: Router, elementRef: ElementRef);\n    private treeHelisaConnect;\n    formEdit: FormControl;\n    tree: MatTree<{}>;\n    private selectedOptions;\n    /**\n     * Datos del Arbol\n     */\n    data: Node;\n    /**\n     * Retorna el id del nodo removido\n     */\n    removed: EventEmitter<string | number>;\n    /**\n     * Retorna un nodo editado\n     */\n    edited: EventEmitter<Node>;\n    /**\n     * Retorna un nodo sin id del nodo , pero si con el parent\n     * para conocer a cual fue a√±adido\n     */\n    added: EventEmitter<Node>;\n    collapseParent: EventEmitter<boolean>;\n    rangeScrolled: EventEmitter<RequestTreeHelisa>;\n    nodeSelected: EventEmitter<number | string>;\n    dobleClick: EventEmitter<number | string>;\n    keypressDelete: EventEmitter<number | string | null>;\n    keypressInsert: EventEmitter<number | string | null>;\n    checkedOptionNode: EventEmitter<number | string | null>;\n    uncheckedOptionNode: EventEmitter<number | string | null>;\n    clickAddNode: EventEmitter<Node>;\n    clickEditNode: EventEmitter<Node>;\n    clickDeleteNode: EventEmitter<Node>;\n    treeControl: NestedTreeControl<Node>;\n    dataSource: MatTreeNestedDataSource<Node>;\n    isSingleClick: boolean;\n    currentNode: Node;\n    /**\n     * Obtiene la descripcion completa del nodo\n     * @example Nodo padre,nodo hijo,nodo nieto\n     * @param node Debe tener todos los parent llenos hacia arriba\n     */\n    static getDescription(node: Node): string;\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    onRedirect(node: Node): void;\n    onScroll(event: Event): void;\n    onEdit(node: Node): void;\n    onAdd(node: Node): void;\n    onDelete(node: Node): void;\n    onEdited(node: Node, value: string): void;\n    onCancel(node: Node, value: string): void;\n    onDblClick(node: Node): void;\n    onKeyDown(event: KeyboardEvent): void;\n    private moveUpIntoTree;\n    private moveDownIntoTree;\n    /**\n     * Verifica si el nodo tiene hijos\n     */\n    hasChild(t: number, node: Node): boolean;\n    /**\n     * Actualiza el arbol borrando toda la data , solo cuando no se utiliza paginacion\n     */\n    private refreshTree;\n    /**\n     * Actualiza el arbol cuando se utiliza la paginacion (Cuando no , utilice el metodo refreshTree())\n     */\n    private refreshTreeWithPagination;\n    private goNextPage;\n    private receivePage;\n    /**\n     * Llenan el campo parent de todos los nodos hijos\n     */\n    private fillParent;\n    /**\n     * coloca como true del isSelected del nodo que concuerde con el id\n     */\n    private selectNode;\n    private expandAllParents;\n    /**\n     * Elimina el isSelected de todos los nodos\n     */\n    private upSelectNode;\n    getClassNode(node: Node): string[];\n    onEditMode(node: Node, editMode: boolean): void;\n    onSelectOption(event: MatOptionSelectionChange, node: Node): void;\n    getSelectedOptions(node: Node): {\n        formControl: FormControl;\n        editMode: boolean;\n    };\n    private reloadSelectedOptions;\n    /**\n     * Retorna el primer Node que encuentre segun el id enviado o null si no hay ninguno\n     * @param id  number | string\n     * @returns Node o null si no hay un nodo con ese id\n     */\n    getNodeById(id: number | string): Node;\n    reorderByOrderIndex(node: Node[]): Node[];\n}\n"]}